{% extends 'base.html' %}
{% load static %}
{% load bootstrap %}

<!doctype html>
<html lang="en">
<head>

    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">
    <link rel="stylesheet" href="{% static 'chart.css' %}">
    {% block title %} Charts panel {% endblock %}

</head>
<body>
{% block content %}

    <h1>Live sensors data charts</h1>
    <div class="chart-container" id="myCharts">
    </div>



    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>

        // Inicjalizacja zmiennych
        var number_charts = {}; //obiekt przechowujący wykresy dla różnych sensorów
        var maxColumns = 8; //ilość kolumn
        var sensors_counter = 1; //licznik sensorów
        var device_dict = {}; //słownik przechowywujący dane sensorów i urządzenia
        var isFirstMessage = true; //flaga określająca czy jest to pierwsza wiadomość

        // Pobranie danych o sensorach i posortowanie ich po numerze PIN
        var sensorsData = {{ sensors_data|safe }};
        sensorsData.sort((a, b) => a.pin_number - b.pin_number); // sort by pin_number
        console.log("Dane sensorów:", sensorsData);

        // Wiadomość do wysłania przez WebSocket
        var message = {
            token: "{{ access_token }}"
        };

        // Wypisanie wiadomości w formacie JSON w konsoli
        console.log(JSON.stringify(message));

        // Inicjacja połączenia z WebSocket
        var socket = new WebSocket('ws://localhost:8000/device/{{ device_id }}/sensor/data');
        socket.onopen = function () {
            // Wysłanie wiadomości w formacie JSON do WebSocket po nawiązaniu połączenia
            socket.send(JSON.stringify(message));
        };

        // Obsługa otrzymanej wiadomości przez WebSocket
        socket.onmessage = function (e) {
            var wsData = JSON.parse(e.data);

            // Iteracja przez dane sensorów

            // Jeśli to jest pierwsza wiadomość
            if (isFirstMessage) {
                isFirstMessage = false; // Ustawienie flagi na false po otrzymaniu pierwszej wiadomości

                // Iteracja przez dane urządzenia
                for (var mac_address in wsData) {
                    if (!device_dict.hasOwnProperty(mac_address)) {
                        device_dict[mac_address] = {};
                    }
                    for (var sensor_id in wsData[mac_address]) {
                        if (!device_dict[mac_address].hasOwnProperty(sensor_id)) {
                            // Inicjalizacja danych sensora
                            device_dict[mac_address][sensor_id] = {
                                timestamp: [],
                                value: []
                            };
                            sensors_counter++;
                        }

                        // Dodanie danych do sensora
                        device_dict[mac_address][sensor_id]['timestamp'].push(wsData[mac_address][sensor_id]['timestamp']);
                        device_dict[mac_address][sensor_id]['value'].push(wsData[mac_address][sensor_id]['value']);

                        // Usunięcie zbędnych danych, jeśli przekroczono limit
                        if (device_dict[mac_address][sensor_id]['timestamp'].length > maxColumns) {
                            device_dict[mac_address][sensor_id]['timestamp'].shift();
                        }
                        if (device_dict[mac_address][sensor_id]['value'].length > maxColumns) {
                            device_dict[mac_address][sensor_id]['value'].shift();
                        }
                    }
                }

                // Wyświetlenie informacji o ilości sensorów i danych urządzenia
                console.log("Suma ilości zmiennych sensor_id: " + (sensors_counter - 1));
                console.log(device_dict);

                // Tworzenie wykresów dla sensorów
                for (var x in device_dict) {
                    for (var y in device_dict[x]) {
                        const ctx2 = document.getElementById("myCharts");
                        var ctx = document.createElement('canvas');
                        ctx.id = y;
                        ctx2.appendChild(ctx);
                        ctx_now = document.getElementById(y);
                        number_charts[y] = new Chart(ctx_now, {
                            type: 'line',
                            data: {
                                labels: [2],
                                datasets: [{
                                    label: 'Terrarium data: ',
                                    data: [1],
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                fill: true,
                                maintainAspectRatio: true,
                                scales: {
                                    y: {
                                        beginAtZero: false,
                                        min: 1,
                                        max: 80
                                    }
                                },
                                animation: {
                                    duration: 0
                                }
                            }
                        });
                    }
                }

                // Funkcja do formatowania daty
                function formatDate(timestamp) {
                    const date = new Date(timestamp);
                    const year = date.getFullYear();
                    const month = (date.getMonth() + 1).toString().padStart(2, '0');
                    const day = date.getDate().toString().padStart(2, '0');
                    const hours = date.getHours().toString().padStart(2, '0');
                    const minutes = date.getMinutes().toString().padStart(2, '0');
                    return `${year}-${month}-${day}, ${hours}:${minutes}`;
                }

                // Aktualizacja danych wykresu
                for (var j in device_dict) {
                    for (var z in device_dict[j]) {
                        // Przetwarzanie etykiet czasu bez dodatkowej zmiennej
                        number_charts[z].data.labels = device_dict[j][z]['timestamp'].map(timestamp => {
                            const date = new Date(timestamp);
                            const formattedDate = date.toLocaleDateString();
                            const formattedTime = date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                            return `${formattedDate}, ${formattedTime}`;
                        });

                        number_charts[z].data.datasets[0].data = device_dict[j][z]['value'].map(value => parseFloat(value).toFixed(2));
                        number_charts[z].data.datasets[0].label = parseFloat(device_dict[j][z]['value'][0]).toFixed(2);

                        // Dodanie etykiety reprezentującej sensor
                        const sensorIndex = sensorsData.findIndex(sensor => sensor.pin_number === parseInt(z));
                        const sensorData = sensorIndex !== -1 ? sensorsData[sensorIndex] : {
                            name: 'Unknown',
                            type: 'Unknown'
                        };
                        const sensorLabel = `Sensor PIN: ${z}, Name: ${sensorData.name}, Type: ${sensorData.type}`;


                        number_charts[z].options.plugins = {
                            legend: {
                                display: true,
                                labels: {
                                    generateLabels: function (chart) {
                                        const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                        labels[0].text = sensorLabel; // Aktualizacja etykiety
                                        return labels;
                                    }
                                }
                            }
                        };

                        number_charts[z].options.animation.duration = 0;
                        number_charts[z].update();
                    }
                }
            } else {
                // Obsługa pozostałych wiadomości
                // Aktualizacja danych wykresu bez ponownego pobierania sumy sensorów
                for (var j in device_dict) {
                    for (var y in device_dict[j]) {
                        const updatedTimestamp = wsData[j][y]['timestamp'];
                        const updatedValue = wsData[j][y]['value'];

                        device_dict[j][y]['timestamp'].push(updatedTimestamp);
                        device_dict[j][y]['value'].push(updatedValue);

                        if (device_dict[j][y]['timestamp'].length > maxColumns) {
                            device_dict[j][y]['timestamp'].shift();
                        }
                        if (device_dict[j][y]['value'].length > maxColumns) {
                            device_dict[j][y]['value'].shift();
                        }

                        // Aktualizacja wykresu
                        number_charts[y].data.labels = device_dict[j][y]['timestamp'].map(timestamp => {
                            const date = new Date(timestamp);
                            const formattedDate = date.toLocaleDateString();
                            const formattedTime = date.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                            return `${formattedDate}, ${formattedTime}`;
                        });

                        number_charts[y].data.datasets[0].data = device_dict[j][y]['value'].map(value => parseFloat(value).toFixed(2));
                        number_charts[y].data.datasets[0].label = parseFloat(updatedValue).toFixed(2);
                        number_charts[y].options.animation.duration = 0;
                        number_charts[y].update();
                    }
                }
            }
        };

    </script>
{% endblock %}
</body>
</html>


